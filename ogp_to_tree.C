//Converts a "petal##_edges.DAT" file into a .ogp_tree.root file.
// the ogp_tree contains a TTree with petal#, stripe#, and TVector3 for every point in the survey.
//this is processed by ogp_tree_to_petal_tree.C to make a tree containing only the area and position of each stripe, not its full outline.
//if you're curious, 'ogp' stands for Optical Gaging Machine.
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include "TTree.h"
#include "TFile.h"
#include "TVector3.h"

int FindEmbeddedInteger(const std::string& input) {
 // Function generated by ChatGPT to 'extract a single integer from a filename with no spaces'
   int result = 0;
    bool foundDigit = false;

    for (char c : input) {
        if (std::isdigit(c)) {
            result = result * 10 + (c - '0');
            foundDigit = true;
        } else if (foundDigit) {
            // Stop if a non-digit character is encountered after finding a digit
            break;
        }
    }
    return result;
}

bool HasData(const std::string& line) {
 // Function generated by ChatGPT to 'check if the line starts with a plus or minus sign'
  //since the carraige returns are screwing up 'readpoint'.
    if (!line.empty() && (line[0] == '+' || line[0] == '-')) {
        return true;
    } else {
        return false;
    }
}

TVector3 ReadPoint(const std::string& input) {
    std::istringstream iss(input);
    double x=0,y=0,z=0;
    if (!(iss >> x)) {
        std::cerr << "Error: Unable to parse the X coordinate." << std::endl;
    printf("input='%s'\n",input.c_str());
	assert(false);
    } else if (!(iss >> y)) {
        std::cerr << "Error: Unable to parse the Y coordinate." << std::endl;
	assert(false);
    } else if (!(iss >> z)) {
        std::cerr << "Error: Unable to parse the Z coordinate." << std::endl;
	assert(false);
    }   
    return TVector3(x, y, z);
}


int ReadContourType(const std::string& input) {
    if (input.find("Contour") != std::string::npos) {
        return 1;
    } else if (input.find("Circle") != std::string::npos) {
        return 2;
    } else {
        return 0;
    }
}

int ReadLastInteger(const std::string& input) {
    std::istringstream iss(input);
    std::string token;
    int lastInteger = -1; // Initialize to a default value in case no integer is found

    while (iss >> token) {
        std::istringstream token_ss(token);
        int num;
        if (token_ss >> num) {
            lastInteger = num;
        }
    }

    return lastInteger;
}


void ogp_to_tree(const char* input_filename, const char* output_filename)
{
    // Open the input file
    std::ifstream input_file(input_filename);
    if (!input_file.is_open()) {
        std::cerr << "Error opening input file: " << input_filename << std::endl;
        return;
    }
    
    // Create the TTree and its branches
    TFile* output_file = new TFile(output_filename, "RECREATE");
    TTree* tree = new TTree("ogpTree", "ogpTree");
    int i=0;
    int petal=FindEmbeddedInteger(input_filename);
    int ogpIndex=0; //index of the mark in the ogp numbering scheme
    int perimeterIndex=0; // point index along the perimeter of this stripe/circle
    bool isStripe, isCircle;
    TVector3 p;
    tree->Branch("petal", &petal);
    tree->Branch("isStripe", &isStripe);
    tree->Branch("isCircle", &isCircle);
    tree->Branch("ogpIndex",&ogpIndex);
    tree->Branch("i",&perimeterIndex);
    tree->Branch("p", &p);

    
    // Read the .DAT file line by line and fill the TTree
    float ret=-9000;
    std::string line;
    std::string leader="C";//Contour, Circle, and C:\ all start with this capital letter.
    while(getline(input_file, line) ){ //read data from file object and put it into string.
      
      if (line.find(leader)!=std::string::npos){
	//if we find a leader line, update our stripe data:
	int outlineType=ReadContourType(line);
	if (outlineType>0){ //either a Circle or a Contour

	  //handle the naming conventions:
	  isStripe=(outlineType==1);
	  isCircle=(outlineType==2);
	  ogpIndex=ReadLastInteger(line);//taking advantage of the format that is either "Circle  #" or "Contour  #"
	  //benIndex=ConvertOgpToBen(ogpIndex);
	  perimeterIndex=0;
	  printf("Found %s %d.\n",isStripe?"Stripe":isCircle?"Circle":"Garbage",ogpIndex);
	}
      } else if (HasData(line)){
	p=ReadPoint(line);
	tree->Fill();
	perimeterIndex++;
      } else {
	printf("Ending %s %d with %d points\n",isStripe?"Stripe":isCircle?"Circle":"Garbage",ogpIndex,perimeterIndex);
      }
    }


    input_file.close();
    
    // Save the TTree to a ROOT file
    if (!output_file->IsOpen()) {
        std::cerr << "Error opening output file: " << output_filename << std::endl;
        return;
    }
    tree->Write();
    output_file->Close();
}
